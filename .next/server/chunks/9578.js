"use strict";exports.id=9578,exports.ids=[9578],exports.modules={19578:(a,b,c)=>{c.d(b,{fromIni:()=>z});var d=c(66008),e=c(55042),f=c(64262),g=c(89701),h=c(76552);let i=a=>(0,g.g)(a,"CREDENTIALS_PROFILE_NAMED_PROVIDER","p"),j=async(a,b,d,j,l={},m)=>{d.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");let n=b[a],{source_profile:o,region:p}=n;if(!d.roleAssumer){let{getDefaultRoleAssumer:a}=await c.e(6526).then(c.bind(c,76526));d.roleAssumer=a({...d.clientConfig,credentialProviderLogger:d.logger,parentClientConfig:{...j,...d?.parentClientConfig,region:p??d?.parentClientConfig?.region??j?.region}},d.clientPlugins)}if(o&&o in l)throw new f.C(`Detected a cycle attempting to resolve credentials for profile ${(0,e.Bz)(d)}. Profiles visited: `+Object.keys(l).join(", "),{logger:d.logger});d.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${o?`source_profile=[${o}]`:`profile=[${a}]`}`);let q=o?m(o,b,d,j,{...l,[o]:!0},k(b[o]??{})):(await ((a,b,d)=>{let e={EcsContainer:async a=>{let{fromHttp:b}=await c.e(6554).then(c.bind(c,56554)),{fromContainerMetadata:e}=await c.e(7024).then(c.bind(c,37024));return d?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer"),async()=>(0,h.c)(b(a??{}),e(a))().then(i)},Ec2InstanceMetadata:async a=>{d?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");let{fromInstanceMetadata:b}=await c.e(7024).then(c.bind(c,37024));return async()=>b(a)().then(i)},Environment:async a=>{d?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");let{fromEnv:b}=await c.e(6294).then(c.bind(c,86294));return async()=>b(a)().then(i)}};if(a in e)return e[a];throw new f.C(`Unsupported credential source in profile ${b}. Got ${a}, expected EcsContainer or Ec2InstanceMetadata or Environment.`,{logger:d})})(n.credential_source,a,d.logger)(d))();if(k(n))return q.then(a=>(0,g.g)(a,"CREDENTIALS_PROFILE_SOURCE_PROFILE","o"));{let b={RoleArn:n.role_arn,RoleSessionName:n.role_session_name||`aws-sdk-js-${Date.now()}`,ExternalId:n.external_id,DurationSeconds:parseInt(n.duration_seconds||"3600",10)},{mfa_serial:c}=n;if(c){if(!d.mfaCodeProvider)throw new f.C(`Profile ${a} requires multi-factor authentication, but no MFA code callback was provided.`,{logger:d.logger,tryNextLink:!1});b.SerialNumber=c,b.TokenCode=await d.mfaCodeProvider(c)}let e=await q;return d.roleAssumer(e,b).then(a=>(0,g.g)(a,"CREDENTIALS_PROFILE_SOURCE_PROFILE","o"))}},k=a=>!a.role_arn&&!!a.credential_source;var l=c(15796),m=c(41358),n=c(77598),o=c(73024),p=c(48161),q=c(76760);class r{profileData;init;callerClientConfig;static REFRESH_THRESHOLD=3e5;constructor(a,b,c){this.profileData=a,this.init=b,this.callerClientConfig=c}async loadCredentials(){let a=await this.loadToken();if(!a)throw new f.C(`Failed to load a token for session ${this.loginSession}, please re-authenticate using aws login`,{tryNextLink:!1,logger:this.logger});let b=a.accessToken,c=Date.now();return new Date(b.expiresAt).getTime()-c<=r.REFRESH_THRESHOLD?this.refresh(a):{accessKeyId:b.accessKeyId,secretAccessKey:b.secretAccessKey,sessionToken:b.sessionToken,accountId:b.accountId,expiration:new Date(b.expiresAt)}}get logger(){return this.init?.logger}get loginSession(){return this.profileData.login_session}async refresh(a){let b,{SigninClient:d,CreateOAuth2TokenCommand:e}=await c.e(3846).then(c.bind(c,63846)),{logger:g,userAgentAppId:h}=this.callerClientConfig??{},i=(b=this.callerClientConfig?.requestHandler,b?.metadata?.handlerProtocol==="h2")?void 0:this.callerClientConfig?.requestHandler,j=new d({credentials:{accessKeyId:"",secretAccessKey:""},region:this.profileData.region??await this.callerClientConfig?.region?.()??process.env.AWS_REGION,requestHandler:i,logger:g,userAgentAppId:h,...this.init?.clientConfig});this.createDPoPInterceptor(j.middlewareStack);let k={tokenInput:{clientId:a.clientId,refreshToken:a.refreshToken,grantType:"refresh_token"}};try{let b=await j.send(new e(k)),{accessKeyId:c,secretAccessKey:d,sessionToken:g}=b.tokenOutput?.accessToken??{},{refreshToken:h,expiresIn:i}=b.tokenOutput??{};if(!c||!d||!g||!h)throw new f.C("Token refresh response missing required fields",{logger:this.logger,tryNextLink:!1});let l=new Date(Date.now()+(i??900)*1e3),m={...a,accessToken:{...a.accessToken,accessKeyId:c,secretAccessKey:d,sessionToken:g,expiresAt:l.toISOString()},refreshToken:h};await this.saveToken(m);let n=m.accessToken;return{accessKeyId:n.accessKeyId,secretAccessKey:n.secretAccessKey,sessionToken:n.sessionToken,accountId:n.accountId,expiration:l}}catch(a){if("AccessDeniedException"===a.name){let b;switch(a.error){case"TOKEN_EXPIRED":b="Your session has expired. Please reauthenticate.";break;case"USER_CREDENTIALS_CHANGED":b="Unable to refresh credentials because of a change in your password. Please reauthenticate with your new password.";break;case"INSUFFICIENT_PERMISSIONS":b="Unable to refresh credentials due to insufficient permissions. You may be missing permission for the 'CreateOAuth2Token' action.";break;default:b=`Failed to refresh token: ${String(a)}. Please re-authenticate using \`aws login\``}throw new f.C(b,{logger:this.logger,tryNextLink:!1})}throw new f.C(`Failed to refresh token: ${String(a)}. Please re-authenticate using aws login`,{logger:this.logger})}}async loadToken(){let a=this.getTokenFilePath();try{let b;try{b=await (0,m.TA)(a,{ignoreCache:this.init?.ignoreCache})}catch{b=await o.promises.readFile(a,"utf8")}let c=JSON.parse(b),d=["accessToken","clientId","refreshToken","dpopKey"].filter(a=>!c[a]);if(c.accessToken?.accountId||d.push("accountId"),d.length>0)throw new f.C(`Token validation failed, missing fields: ${d.join(", ")}`,{logger:this.logger,tryNextLink:!1});return c}catch(b){throw new f.C(`Failed to load token from ${a}: ${String(b)}`,{logger:this.logger,tryNextLink:!1})}}async saveToken(a){let b=this.getTokenFilePath(),c=(0,q.dirname)(b);try{await o.promises.mkdir(c,{recursive:!0})}catch(a){}await o.promises.writeFile(b,JSON.stringify(a,null,2),"utf8")}getTokenFilePath(){let a=process.env.AWS_LOGIN_CACHE_DIRECTORY??(0,q.join)((0,p.homedir)(),".aws","login","cache"),b=Buffer.from(this.loginSession,"utf8"),c=(0,n.createHash)("sha256").update(b).digest("hex");return(0,q.join)(a,`${c}.json`)}derToRawSignature(a){let b=2;if(2!==a[2])throw Error("Invalid DER signature");b++;let c=a[b++],d=a.subarray(b,b+c);if(2!==a[b+=c])throw Error("Invalid DER signature");b++;let e=a[b++],f=a.subarray(b,b+e);d=0===d[0]?d.subarray(1):d,f=0===f[0]?f.subarray(1):f;let g=Buffer.concat([Buffer.alloc(32-d.length),d]),h=Buffer.concat([Buffer.alloc(32-f.length),f]);return Buffer.concat([g,h])}createDPoPInterceptor(a){a.add(a=>async b=>{if(l.K.isInstance(b.request)){let a=b.request,c=`${a.protocol}//${a.hostname}${a.port?`:${a.port}`:""}${a.path}`,d=await this.generateDpop(a.method,c);a.headers={...a.headers,DPoP:d}}return a(b)},{step:"finalizeRequest",name:"dpopInterceptor",override:!0})}async generateDpop(a="POST",b){let c=await this.loadToken();try{let d=(0,n.createPrivateKey)({key:c.dpopKey,format:"pem",type:"sec1"}),e=(0,n.createPublicKey)(d).export({format:"der",type:"spki"}),f=-1;for(let a=0;a<e.length;a++)if(4===e[a]){f=a;break}let g=e.slice(f+1,f+33),h=e.slice(f+33,f+65),i={alg:"ES256",typ:"dpop+jwt",jwk:{kty:"EC",crv:"P-256",x:g.toString("base64url"),y:h.toString("base64url")}},j={jti:crypto.randomUUID(),htm:a,htu:b,iat:Math.floor(Date.now()/1e3)},k=Buffer.from(JSON.stringify(i)).toString("base64url"),l=Buffer.from(JSON.stringify(j)).toString("base64url"),m=`${k}.${l}`,o=(0,n.sign)("sha256",Buffer.from(m),d),p=this.derToRawSignature(o).toString("base64url");return`${m}.${p}`}catch(a){throw new f.C(`Failed to generate Dpop proof: ${a instanceof Error?a.message:String(a)}`,{logger:this.logger,tryNextLink:!1})}}}let s=async(a,b,c)=>{let h=await (a=>async({callerClientConfig:b}={})=>{a?.logger?.debug?.("@aws-sdk/credential-providers - fromLoginCredentials");let c=await (0,d.Y)(a||{}),h=(0,e.Bz)({profile:a?.profile??b?.profile}),i=c[h];if(!i?.login_session)throw new f.C(`Profile ${h} does not contain login_session.`,{tryNextLink:!0,logger:a?.logger});let j=new r(i,a,b),k=await j.loadCredentials();return(0,g.g)(k,"CREDENTIALS_LOGIN","AD")})({...b,profile:a})({callerClientConfig:c});return(0,g.g)(h,"CREDENTIALS_PROFILE_LOGIN","AC")},t=async(a,b)=>c.e(9885).then(c.bind(c,9885)).then(({fromProcess:c})=>c({...a,profile:b})().then(a=>(0,g.g)(a,"CREDENTIALS_PROFILE_PROCESS","v"))),u=async(a,b,d={},e)=>{let{fromSSO:f}=await c.e(6604).then(c.bind(c,36604));return f({profile:a,logger:d.logger,parentClientConfig:d.parentClientConfig,clientConfig:d.clientConfig})({callerClientConfig:e}).then(a=>b.sso_session?(0,g.g)(a,"CREDENTIALS_PROFILE_SSO","r"):(0,g.g)(a,"CREDENTIALS_PROFILE_SSO_LEGACY","t"))},v=a=>!!a&&"object"==typeof a&&"string"==typeof a.aws_access_key_id&&"string"==typeof a.aws_secret_access_key&&["undefined","string"].indexOf(typeof a.aws_session_token)>-1&&["undefined","string"].indexOf(typeof a.aws_account_id)>-1,w=async(a,b)=>{b?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");let c={accessKeyId:a.aws_access_key_id,secretAccessKey:a.aws_secret_access_key,sessionToken:a.aws_session_token,...a.aws_credential_scope&&{credentialScope:a.aws_credential_scope},...a.aws_account_id&&{accountId:a.aws_account_id}};return(0,g.g)(c,"CREDENTIALS_PROFILE","n")},x=async(a,b,d)=>c.e(5352).then(c.bind(c,75352)).then(({fromTokenFile:c})=>c({webIdentityTokenFile:a.web_identity_token_file,roleArn:a.role_arn,roleSessionName:a.role_session_name,roleAssumerWithWebIdentity:b.roleAssumerWithWebIdentity,logger:b.logger,parentClientConfig:b.parentClientConfig})({callerClientConfig:d}).then(a=>(0,g.g)(a,"CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN","q"))),y=async(a,b,c,d,e={},g=!1)=>{let h=b[a];if(Object.keys(e).length>0&&v(h))return w(h,c);if(g||((a,{profile:b="default",logger:c}={})=>!!a&&"object"==typeof a&&"string"==typeof a.role_arn&&["undefined","string"].indexOf(typeof a.role_session_name)>-1&&["undefined","string"].indexOf(typeof a.external_id)>-1&&["undefined","string"].indexOf(typeof a.mfa_serial)>-1&&(((a,{profile:b,logger:c})=>{let d="string"==typeof a.source_profile&&void 0===a.credential_source;return d&&c?.debug?.(`    ${b} isAssumeRoleWithSourceProfile source_profile=${a.source_profile}`),d})(a,{profile:b,logger:c})||((a,{profile:b,logger:c})=>{let d="string"==typeof a.credential_source&&void 0===a.source_profile;return d&&c?.debug?.(`    ${b} isCredentialSourceProfile credential_source=${a.credential_source}`),d})(a,{profile:b,logger:c})))(h,{profile:a,logger:c.logger}))return j(a,b,c,d,e,y);if(v(h))return w(h,c);if((a=>!!a&&"object"==typeof a&&"string"==typeof a.web_identity_token_file&&"string"==typeof a.role_arn&&["undefined","string"].indexOf(typeof a.role_session_name)>-1)(h))return x(h,c,d);if((a=>!!a&&"object"==typeof a&&"string"==typeof a.credential_process)(h))return t(c,a);if((a=>a&&("string"==typeof a.sso_start_url||"string"==typeof a.sso_account_id||"string"==typeof a.sso_session||"string"==typeof a.sso_region||"string"==typeof a.sso_role_name))(h))return await u(a,h,c,d);if((a=>!!(a&&a.login_session))(h))return s(a,c,d);throw new f.C(`Could not resolve credentials using profile: [${a}] in configuration/credentials file(s).`,{logger:c.logger})},z=(a={})=>async({callerClientConfig:b}={})=>{a.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");let c=await (0,d.Y)(a);return y((0,e.Bz)({profile:a.profile??b?.profile}),c,a,b)}},66008:(a,b,c)=>{c.d(b,{Y:()=>e});var d=c(63882);let e=async a=>{let b=await (0,d.p)(a);return((...a)=>{let b={};for(let c of a)for(let[a,d]of Object.entries(c))void 0!==b[a]?Object.assign(b[a],d):b[a]=d;return b})(b.configFile,b.credentialsFile)}}};